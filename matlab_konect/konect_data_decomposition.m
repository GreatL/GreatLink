%
% Metadata of decompositions.
%
% RESULT 
%	data_decomposition 	Struct of values 
%
% PARAMETERS 
%	decomposition
%	format		(optional) Only used for the names ; default to ASYM
%
% ABOUT 
%	This file is part of the KONECT Matlab Toolbox version 0.3.
%	konect.uni-koblenz.de
%	(c) Jerome Kunegis 2014; this is Free Software released under
%	the GPLv3, see COPYING. 
%

function data_decomposition = konect_data_decomposition(decomposition, format)

consts = konect_consts(); 

if ~exist('format', 'var'), format = consts.ASYM; end

data_decomposition = struct();

% The largest eigenvalue is 1, or less for signed networks. 
data_decomposition.n = ...
  strcmp(decomposition, 'sym-n') | ...
  strcmp(decomposition, 'svd-n') | ...
  strcmp(decomposition, 'stoch1') | ...
  strcmp(decomposition, 'stoch2') | ...
  strcmp(decomposition, 'diag-n') | ...
  strcmp(decomposition, 'hermn'); 
% SKEWN is not in the N category because it is not clear what the
% largest eigenvalue is.   

% Is a Laplacian decomposition, i.e., the dominant eigenvalues as
% small.  
data_decomposition.l = ...
  strcmp(decomposition, 'lap') | ...
  strcmp(decomposition, 'lapd') | ...
  strcmp(decomposition, 'lapd-n') | ...
  strcmp(decomposition, 'lapherm') | ...
  strcmp(decomposition, 'lapherm2') | ...
  strcmp(decomposition, 'lapskew') | ...
  strcmp(decomposition, 'lapquantum') | ...
  strcmp(decomposition, 'lapc') | ...
  strcmp(decomposition, 'lapq');

% The matrix is positive semidefinite
data_decomposition.posdef = data_decomposition.l; 

% The largest latent dimension is trivial, i.e. the eigenvector is
% constant.  
data_decomposition.trivial = ...
  strcmp(decomposition, 'lap') | ...
  strcmp(decomposition, 'stoch1') | ...
  strcmp(decomposition, 'stoch2'); 

% Eigenvectors are orthogonal
data_decomposition.o = ...
  strcmp(decomposition, 'sym') | ...
  strcmp(decomposition, 'sym-n') | ...
  strcmp(decomposition, 'lap') | ...
  strcmp(decomposition, 'svd') | ...
  strcmp(decomposition, 'lapq') | ...
  strcmp(decomposition, 'skew') | ...
  strcmp(decomposition, 'skewi') | ...
  strcmp(decomposition, 'herm') | ...
  strcmp(decomposition, 'hermi') | ...
  strcmp(decomposition, 'lapd') | ...
  strcmp(decomposition, 'lapd-n') | ...
  strcmp(decomposition, 'lapherm') | ...
  strcmp(decomposition, 'lapherm2') | ...
  strcmp(decomposition, 'lapskew') | ...
  strcmp(decomposition, 'lapquantum') | ...
  strcmp(decomposition, 'dedicom1u') | ...
  strcmp(decomposition, 'dedicom1v') | ...
  strcmp(decomposition, 'dedicom2') | ...
  strcmp(decomposition, 'dedicom2s') | ...
  strcmp(decomposition, 'dedicom3') | ...
  strcmp(decomposition, 'dedicom3-0') | ...
  strcmp(decomposition, 'takane') | ...
  strcmp(decomposition, 'quantum') | ...
  (0 ~= length(regexp(decomposition, '^quantum[0-9]+$', 'start'))); 

% Eigenvalues are purely imaginary (not used at the moment)
data_decomposition.i = 0; 

% Predictions are given by the imaginary part of a spectral
% transformation of that decomposition
data_decomposition.imag = ...
  strcmp(decomposition, 'hermi') | ...
  strcmp(decomposition, 'quantum') | ...
  (0 ~= length(regexp(decomposition, '^quantum[0-9]+$', 'start'))); 

% Symbol for the decomposed matrix
if strcmp(decomposition, 'lap')
    data_decomposition.matrix = 'L';
elseif strcmp(decomposition, 'sym-n')
    data_decomposition.matrix = 'N';
else
    data_decomposition.matrix = 'A'; 
end

%
% Symbol and name used for the central values (e.g. "Eigenvalue" or
% "Singular value") 
%

if strcmp(decomposition, 'svd') | ...
   strcmp(decomposition, 'svd-n') | ...
   strcmp(decomposition, 'back') | ...
   (strcmp(decomposition, 'sym') & format == consts.BIP) | ...
   (strcmp(decomposition, 'sym-n') & format == consts.BIP) 
  data_decomposition.value_name = 'Singular value';
  data_decomposition.value_symbol = '\sigma';
else
  data_decomposition.value_name = 'Eigenvalue';
  data_decomposition.value_symbol = '\lambda';
end

%
% Eigenvectors are real
%

data_decomposition.real = ...
  ~ (strcmp(decomposition, 'diag')); 
